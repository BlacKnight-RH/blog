Breakpoint 1 at 0x80483fd: file factorial.c, line 8.

Breakpoint 1, factorial (n=1) at factorial.c:8
8			return 1;
2: $ebp = (void *) 0xbffff674
1: $esp = (void *) 0xbffff66c

Inspect the stack frames:

#0  factorial (n=1) at factorial.c:8
#1  0x08048412 in factorial (n=2) at factorial.c:11
#2  0x08048412 in factorial (n=3) at factorial.c:11
#3  0x08048412 in factorial (n=4) at factorial.c:11
#4  0x08048412 in factorial (n=5) at factorial.c:11
#5  0x08048430 in main (argc=1) at factorial.c:17

Inspect stack contents as words. These are converted little-endian
from individual bytes into 4-byte numbers:

0xbffff66c:	0x00000001	0xdeadbeef	0xbffff684	0x08048412
0xbffff67c:	0x00000001	0xdeadbeef	0xbffff694	0x08048412
0xbffff68c:	0x00000002	0xdeadbeef	0xbffff6a4	0x08048412
0xbffff69c:	0x00000003	0xdeadbeef	0xbffff6b4	0x08048412
0xbffff6ac:	0x00000004	0xdeadbeef	0xbffff6c8	0x08048430
0xbffff6bc:	0x00000005	0x08048450	0x00000000	0x00000000
0xbffff6cc:	0xb7e454d3	0x00000001

Inspect stack contents as bytes, as shown in the diagram:

0xbffff66c:	0x01	0x00	0x00	0x00	0xef	0xbe	0xad	0xde
0xbffff674:	0x84	0xf6	0xff	0xbf	0x12	0x84	0x04	0x08
0xbffff67c:	0x01	0x00	0x00	0x00	0xef	0xbe	0xad	0xde
0xbffff684:	0x94	0xf6	0xff	0xbf	0x12	0x84	0x04	0x08
0xbffff68c:	0x02	0x00	0x00	0x00	0xef	0xbe	0xad	0xde
0xbffff694:	0xa4	0xf6	0xff	0xbf	0x12	0x84	0x04	0x08
0xbffff69c:	0x03	0x00	0x00	0x00	0xef	0xbe	0xad	0xde
0xbffff6a4:	0xb4	0xf6	0xff	0xbf	0x12	0x84	0x04	0x08
0xbffff6ac:	0x04	0x00	0x00	0x00	0xef	0xbe	0xad	0xde
0xbffff6b4:	0xc8	0xf6	0xff	0xbf	0x30	0x84	0x04	0x08
0xbffff6bc:	0x05	0x00	0x00	0x00	0x50	0x84	0x04	0x08
0xbffff6c4:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0xbffff6cc:	0xd3	0x54	0xe4	0xb7	0x01	0x00	0x00	0x00

And here is assembly code for main and factorial:
Dump of assembler code for function main:
   0x0804841e <+0>:	push   %ebp
   0x0804841f <+1>:	mov    %esp,%ebp
   0x08048421 <+3>:	sub    $0xc,%esp
   0x08048424 <+6>:	movl   $0x5,(%esp)
   0x0804842b <+13>:	call   0x80483e4 <factorial>
   0x08048430 <+18>:	mov    %eax,-0x4(%ebp)
   0x08048433 <+21>:	mov    $0x8048520,%eax
   0x08048438 <+26>:	mov    -0x4(%ebp),%edx
   0x0804843b <+29>:	mov    %edx,0x4(%esp)
   0x0804843f <+33>:	mov    %eax,(%esp)
   0x08048442 <+36>:	call   0x8048300 <printf@plt>
   0x08048447 <+41>:	leave  
   0x08048448 <+42>:	ret    
End of assembler dump.
Dump of assembler code for function factorial:
   0x080483e4 <+0>:	push   %ebp
   0x080483e5 <+1>:	mov    %esp,%ebp
   0x080483e7 <+3>:	sub    $0x8,%esp
   0x080483ea <+6>:	movl   $0xdeadbeef,-0x4(%ebp)
   0x080483f1 <+13>:	cmpl   $0x0,0x8(%ebp)
   0x080483f5 <+17>:	je     0x80483fd <factorial+25>
   0x080483f7 <+19>:	cmpl   $0x1,0x8(%ebp)
   0x080483fb <+23>:	jne    0x8048404 <factorial+32>
=> 0x080483fd <+25>:	mov    $0x1,%eax
   0x08048402 <+30>:	jmp    0x804841c <factorial+56>
   0x08048404 <+32>:	mov    0x8(%ebp),%eax
   0x08048407 <+35>:	sub    $0x1,%eax
   0x0804840a <+38>:	mov    %eax,(%esp)
   0x0804840d <+41>:	call   0x80483e4 <factorial>
   0x08048412 <+46>:	mov    %eax,-0x4(%ebp)
   0x08048415 <+49>:	mov    0x8(%ebp),%eax
   0x08048418 <+52>:	imul   -0x4(%ebp),%eax
   0x0804841c <+56>:	leave  
   0x0804841d <+57>:	ret    
End of assembler dump.
